


A - Building the encryption/decryption binaries

Edit the file "configure" and set the variables $ext_degree and
$nb_errors to your favorite value, then run:

> configure ; make

Alternatively, the script configure can be called with two arguments
which will replace $ext_degree and $nb_errors respectively. For instance

> ./configure 12 22

will generate the data files ("params.h" and "cwdata.c") for compiling
the package for a McEliece PK encryption scheme using binary Goppa
codes of length 4096 (2^12) correcting 22 errors. The binaries are
then simply generated by

> make

This will build 4 binary files described in the next section.  Note
that every call to configure will destroy any file that can be
generated by this package (this do not include the files containing
the statistics: "plotdata" and "plotkgendata") and recreates
everything with the new set of parameters.

B - Using the encryption/decryption binaries

1) keygen, which generates pairs of secret and public key. Without
argument, an integer $i is chosen randomly and is used as seed for
generating the keys the secret/public keys are written repectively in
the files "sk$i" and "pk$i". If one argument is given, it is used as
seed. If two arguments are given, no key file will be generated, the
first is a seed and the second is the number of key pairs to be
generated. Statistics on the average number of CPU cycles needed to
produce a key pair is appended to the file "plotkgendata".

2) encrypt, which takes 3 arguments exactly:

> ./encrypt public_key_file cleartext_file output_file

"public_key_file" contains a public key generated by kegen
"output_file" is created or replaces an existing file with the same name

3) decrypt, which takes 3 arguments exactly:

> ./decrypt secret_key_file ciphertext_file output_file

"secret_key_file" contains a secret key generated by kegen
"output_file" is created or replaces an existing file with the same name
decryption fails if "ciphertext_file" is not a concatenation of
ciphertext produced with a public key corresponding to the secret key

4) mce, which is meant for simulations. If no argument is given, it
picks a random key pair, a random message, encrypt the decrypt that
message. If one argument is given it is the number of message
generated for the current key pair. The next two arguments, if
present, are respectively the seed for the key pair used and the seed
for the first message (every subsequent message is generated with a
seed incremented by one). In all cases, a line with the average
running time statistics (in CPU cycles/byte) for encryption and
decryption is appended to the file "plotdata".

C - Building and using the utilities

1) genparams. It is build by

> make genparams

which do not require any configuration. The binary file "genparams"
can then be run with 2 to 4 arguments. The first two arguments are the
extension degree m and the number of errors t used for the Goppa
codes. The next two (optional) arguments, say r and l, are parameters
which specify how to transform binary data into constant weight
words. The argument r is the reduction depth and the argument l is the
number of information bits encoded in the error. If those arguments
are not given the program will try to pick the best values (see cwinfo
below).
genparams is built and used by configure

2) secinfo. It is build by

> make secinfo

Called with two parameters m and t it will give a lower bound of the
logarithm (in base 2) of the binary workfactor for the McEliece
encryption scheme using binary Goppa codes of length 2^m with t
errors. For instance

> ./secinfo 11 32
11      32      88.6334

means that the best known attack for the McEliece encryption scheme
with a block length of 2^11=2048 bits using a 32 error correcting
binary Goppa code has a cost of at least 2^88.6 binary operations.
Calling the program with the first argument m alone, is equivalent to
calling it with all possible values of the error weight t.

3) cwinfo. It is build by

> make cwinfo

Called with three parameters m, t and r, it will give the minimal
number of information bits that can be encoded with the dichotomic
algorithm (used here for constant weight words generation). For
instance:

> ./cwinfo 11 32 2
11	32	2	232	232.766	232.773	233.986

means that at least 232 bits can be encoded in one word of length
2^11=2048 and weight 32 with a reduction depth of 2. A reduction of 2
means that in fact words of length 2^9=512 (9=11-2) and weight 32 are
produced and then 2 bits are added to each position. In fact with the
following call:

> ./cwinfo 9 32 0
9       32      0       168     168.766 168.773 168.91

we get essentially the same result as 168 + 32 * 2 = 232.
Three floating point number meaning is the following:
* the first is a lower bound on the minimal self-information of a
  constant weight word (CWW) generated by the dichotomic algorithm
  (the self-information is the opposite of the logarithm in base 2 of
  the probability of obtaining one particular CWW, it is also the
  number of information bits which can be encoded in one particular
  CWW).
* the second is an upper bound on the same minimal self-information.
* the third is the logarithm in base 2 of binomial(2^m,t), the maximal
  number of bits for a CWW

3bis) cwinfo_full. It is build by

> make cwinfo_full

It is the same thing as cwinfo except in one case, when there is an
integer between the lower and upper bounds obtained by cwinfo.
Examples:

> ./cwinfo_full 11 61 1
11      61      1       389     389.98  390.001 391.634
                        389     389.999
> ./cwinfo_full 11 57 0
11      57      0       370     370.996 371.013 371.38
                        371     371

In the first example, an instance of CWW generation was found with a
self-information smaller than 390 bits. In the second example, the
program has a proof that all CWW have a self-information of at least
371 bits. The running time of cwinfo_full can be high and is not
easily predictable; it consists of a tree search. Each leaf of that
tree is a a set of CWW which are produced with the same probability
(i.e. the same self-information). When a leaf has a self-information
lower than the target (an integer, 390 or 371 in the examples) it is
usually found very quickly. We can produce a tight lower bound for the
self-information of the leafs of any subtree, this allows the
elimination af many branches, but when all the self-information are
higher than the target the number of nodes to explore can be large.
